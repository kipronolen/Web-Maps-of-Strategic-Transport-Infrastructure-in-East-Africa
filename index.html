<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Maps of Strategic Transport Infrastructure in East Africa</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>

  <!-- Font Awesome (icons) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />

  <!-- Supabase JS v2 -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root {
      --bg: #070b16; --panel: #0c1327; --panel-2: #0a1124; --text: #eef3fb; --muted: #a6b6cc;
      --brand: #62b0ff; --accent: #44e3b3; --danger: #ff6b6b; --border: #223154;
    }
    html, body { height: 100%; margin: 0; font-family: Inter, system-ui, Segoe UI, Roboto, Arial; background: var(--bg); color: var(--text); }
    #app { display: grid; grid-template-columns: 380px 1fr; grid-template-rows: auto 1fr; height: 100%; }
    header { grid-column: 1 / 3; display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 12px 16px; background: linear-gradient(0deg, var(--panel), var(--panel-2)); border-bottom: 1px solid var(--border); }
    header h1 { font-size: 18px; margin: 0; letter-spacing: 0.2px; font-weight: 650; }
    header .right { display: flex; align-items: center; gap: 8px; }
    .btn { background: var(--brand); color: #061120; border: none; border-radius: 12px; padding: 8px 12px; font-weight: 600; cursor: pointer; transition: 120ms ease; }
    .btn.secondary { background: #142145; color: var(--text); border: 1px solid var(--border); }
    .btn:hover { filter: brightness(1.08); }

    #panel { grid-column: 1; grid-row: 2; background: var(--panel); border-right: 1px solid var(--border); overflow: auto; }
    #map { grid-column: 2; grid-row: 2; height: 100%; width: 100%; }

    .section { padding: 14px 14px 0; }
    .card { background: #0c1430; border: 1px solid var(--border); border-radius: 16px; padding: 12px; margin-bottom: 12px; box-shadow: 0 6px 20px rgba(0,0,0,0.2); }
    .card h3 { margin: 0 0 8px; font-size: 14px; color: var(--muted); font-weight: 700; text-transform: uppercase; letter-spacing: 0.8px; }
    .field { display: grid; gap: 6px; margin-bottom: 10px; }
    .field label { font-size: 12px; color: var(--muted); }
    .field select, .field input { background: #0a1330; color: var(--text); border: 1px solid var(--border); border-radius: 10px; padding: 8px; outline: none; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

    .legend { font-size: 12px; color: var(--muted); line-height: 1.4; display: grid; gap: 6px; }
    .legend .item { display: flex; align-items: center; gap: 10px; margin: 2px 0; }
    .legend .marker-swatch { display:inline-flex; align-items:center; justify-content:center; width:16px; height:16px; }
    .legend .line-swatch { width: 24px; height: 6px; border-radius: 2px; background:#eab308; border: 1px solid #00000033; }

    .loading { position: absolute; top: 70px; right: 20px; background: #0c1430; border: 1px solid var(--border); border-radius: 12px; padding: 8px 10px; display: none; z-index: 1000; }

    .fa-div { display:flex; align-items:center; justify-content:center; width:28px; height:28px; border-radius:14px; border:1px solid #0003; background:#1f2937; color:#fff; box-shadow:0 2px 8px rgba(0,0,0,.35); }
    .fa-div.port-blue { background:#1d4ed8; }
    .fa-div.port-orange { background:#ea580c; }
    .fa-div.air-blue { background:#1e3a8a; }
    .fa-div.air-green { background:#166534; }
    .fa-div.air-purple { background:#5b21b6; }
    .fa-div.air-gray { background:#475569; }
  </style>
</head>
<body>
<div id="app">
  <header>
    <h1>Web Maps of Strategic Transport Infrastructure in East Africa</h1>
    <div class="right">
      <button class="btn secondary" id="btnFit">Fit to data</button>
      <button class="btn" id="btnReload">Reload</button>
    </div>
  </header>

  <aside id="panel">
    <div class="section">
      <!-- Connection UI removed previously; auto connects on load -->

      <div class="card">
        <h3>Layers</h3>
        <div class="layer-toggles">
          <label class="chip"><input type="checkbox" id="toggleCountries" checked /> Countries</label>
          <label class="chip"><input type="checkbox" id="togglePorts" checked /> Ports</label>
          <label class="chip"><input type="checkbox" id="toggleAirports" checked /> Airports</label>
          <label class="chip"><input type="checkbox" id="toggleCities" checked /> Cities</label>
          <label class="chip"><input type="checkbox" id="toggleRoutes" checked /> Routes</label>
        </div>
        <div class="field" style="margin-top:8px">
          <label><input type="checkbox" id="autoRefresh" checked /> Auto refresh on zoom</label>
        </div>
      </div>

      <form class="card" id="airportsForm">
        <h3>Filter airports</h3>
        <div class="row">
          <div class="field">
            <label>Country code</label>
            <select id="airCountry"><option value="">All</option></select>
          </div>
          <div class="field">
            <label>Type</label>
            <select id="airType">
              <option value="">All</option>
              <option value="large_airport" selected>Large</option>
              <option value="medium_airport">Medium</option>
              <option value="small_airport">Small</option>
              <option value="heliport">Heliport</option>
              <option value="closed">Closed</option>
            </select>
          </div>
        </div>
        <div class="row">
          <button type="submit" class="btn">Apply</button>
          <button type="button" id="airportsReset" class="btn secondary">Reset</button>
        </div>
      </form>

      <form class="card" id="portsForm">
        <h3>Filter ports</h3>
        <div class="row">
          <div class="field">
            <label>Country</label>
            <select id="portCountry"><option value="">All</option></select>
          </div>
          <div class="field">
            <label>Type</label>
            <select id="portType">
              <option value="">All</option>
              <option value="Sea">Sea</option>
              <option value="Lake">Lake</option>
            </select>
          </div>
        </div>
        <div class="row">
          <button type="submit" class="btn">Apply</button>
          <button type="button" id="portsReset" class="btn secondary">Reset</button>
        </div>
      </form>

      <form class="card" id="citiesForm">
        <h3>Filter cities</h3>
        <div class="row">
          <div class="field">
            <label>Country</label>
            <select id="cityCountry"><option value="">All</option></select>
          </div>
          <div class="field">
            <label>Classes</label>
            <label><input type="checkbox" id="cityMega" checked /> Megacities</label>
            <label><input type="checkbox" id="cityLarge" checked /> Large Cities</label>
          </div>
        </div>
        <div class="row">
          <button type="submit" class="btn">Apply</button>
          <button type="button" id="citiesReset" class="btn secondary">Reset</button>
        </div>
      </form>

      <div class="card">
        <h3>Map legend</h3>
        <div class="legend" id="legend">
          <!-- Filled by JS to ensure exact icon parity with map -->
        </div>
      </div>

      <div class="card">
        <h3>Feature info</h3>
        <div id="featureInfo" class="legend" role="region" aria-live="polite">Click a feature to see its attributes.</div>
      </div>

      <div class="card">
        <h3>Diagnostics</h3>
        <div class="row">
          <button class="btn" id="btnRunTests" type="button">Run tests</button>
          <button class="btn secondary" id="btnClearTests" type="button">Clear</button>
        </div>
        <pre id="diag" aria-live="polite"></pre>
      </div>
    </div>
  </aside>

  <div id="map"></div>
</div>

<div class="loading" id="loading">Loading data…</div>

<script>
  // Wrap all logic so it only runs after DOM is ready
  document.addEventListener('DOMContentLoaded', function() {
    // Defaults for auto connect
    const DEFAULT_URL = "https://pbfscipxvkmryfwinhkw.supabase.co";
    const DEFAULT_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBiZnNjaXB4dmttcnlmd2luaGt3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ5ODExMjksImV4cCI6MjA3MDU1NzEyOX0.QCRw_cpoZcKVNeP_WpyJNeIs0sy6siC40-Fm79OnfXQ";

    // Countries GeoJSON in Storage
    // Set your bucket name and file path here
    const STORAGE_BUCKET = 'EastAfrica';
    const COUNTRIES_FILE = 'Easern Africa1.geojson';
    // Public bucket: false. Private bucket: true (uses short-lived signed URL)
    const USE_SIGNED_URL_FOR_COUNTRIES = false;

    const LIMIT_TO_BBOX = false;
    let AUTO_REFRESH_ON_ZOOM = true;

    // Idle auto-fit: 90 seconds
    const IDLE_MS = 90 * 1000;
    let idleTimer = null;
    function onIdleAutoFit() {
      try { fitToData(); logDiag('Auto fit to data after idle'); }
      catch (e) { logDiag(`Auto fit failed: ${e.message || e}`, false); }
    }
    function resetIdleTimer() { if (idleTimer) clearTimeout(idleTimer); idleTimer = setTimeout(onIdleAutoFit, IDLE_MS); }
    window.getIdleMs = () => IDLE_MS;
    window._test_triggerIdle = () => onIdleAutoFit();

    const EA_ISO = ["KE","UG","TZ","RW","BI","ET","ER","DJ","SO","SS","SD","CD"];
    const EA_COUNTRIES = [
      "Kenya","Uganda","Tanzania","Rwanda","Burundi","Ethiopia","Eritrea","Djibouti","Somalia","South Sudan","Sudan","Democratic Republic of Congo","DR Congo","Congo, Democratic Republic of the"
    ];

    let supabaseClient = null;

    const loading = document.getElementById("loading");
    function showLoading(flag) { loading.style.display = flag ? "block" : "none"; }

    // Map and layers
    const map = L.map("map", { zoomControl: true }).setView([0.5, 34.5], 5);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { attribution: "© OpenStreetMap" }).addTo(map);

    // Layer containers without clustering
    const airportsLayer = L.layerGroup();
    const portsLayer    = L.layerGroup();
    const citiesLayer   = L.layerGroup();
    const routesLayer   = L.layerGroup();
    const countriesLayer= L.geoJSON(null, { style: { color: "#94a3b8", weight: 1, fillColor: "#334155", fillOpacity: 0.15 }, onEachFeature: (feature, layer) => { layer.on('click', () => showAttributes('Country', (feature && feature.properties) ? feature.properties : {})); } });

    airportsLayer.addTo(map);
    portsLayer.addTo(map);
    citiesLayer.addTo(map);
    routesLayer.addTo(map);
    countriesLayer.addTo(map);

    // Controls
    const btnReload = document.getElementById("btnReload");
    const btnFit = document.getElementById("btnFit");
    const btnRunTests = document.getElementById("btnRunTests");
    const btnClearTests = document.getElementById("btnClearTests");
    const diag = document.getElementById("diag");

    btnReload.addEventListener("click", () => loadAll({ doFit: false }));
    btnFit.addEventListener("click", fitToData);
    btnRunTests.addEventListener("click", runTests);
    btnClearTests.addEventListener("click", () => { diag.textContent = ""; });

    function logDiag(line, ok = true) {
      const prefix = ok ? "[PASS]" : "[FAIL]";
      const span = document.createElement('span');
      span.textContent = `${prefix} ${line}\n`;
      span.className = ok ? 'test-pass' : 'test-fail';
      diag.appendChild(span);
    }

    function fitToData() {
      const group = new L.featureGroup([airportsLayer, portsLayer, citiesLayer, routesLayer, countriesLayer]);
      try { map.fitBounds(group.getBounds().pad(0.1)); } catch (_) { map.setView([0.5, 34.5], 5); }
    }

    // Toggles
    const tCountries = document.getElementById("toggleCountries");
    const tPorts = document.getElementById("togglePorts");
    const tAirports = document.getElementById("toggleAirports");
    const tCities = document.getElementById("toggleCities");
    const tRoutes = document.getElementById("toggleRoutes");
    const autoRefresh = document.getElementById("autoRefresh");

    tCountries.addEventListener("change", () => tCountries.checked ? countriesLayer.addTo(map) : map.removeLayer(countriesLayer));
    tPorts.addEventListener("change", () => tPorts.checked ? portsLayer.addTo(map) : map.removeLayer(portsLayer));
    tAirports.addEventListener("change", () => tAirports.checked ? airportsLayer.addTo(map) : map.removeLayer(airportsLayer));
    tCities.addEventListener("change", () => tCities.checked ? citiesLayer.addTo(map) : map.removeLayer(citiesLayer));
    tRoutes.addEventListener("change", () => tRoutes.checked ? routesLayer.addTo(map) : map.removeLayer(routesLayer));
    autoRefresh.addEventListener('change', () => { AUTO_REFRESH_ON_ZOOM = autoRefresh.checked; });

    // Refresh on zoom without auto-fit
    map.on('zoomend', async () => { if (AUTO_REFRESH_ON_ZOOM && supabaseClient) { await loadAll({ doFit: false }); }});

    // Idle timer hooks
    const idleEvents = ['click','mousemove','keydown','scroll','touchstart','wheel','pointerdown','pointerup','focus'];
    idleEvents.forEach(ev => window.addEventListener(ev, resetIdleTimer, { passive: true }));
    map.on('zoomstart zoomend move moveend dragstart dragend resize', resetIdleTimer);
    resetIdleTimer();

    // Form elements
    const airCountrySel = document.getElementById("airCountry");
    const airTypeSel = document.getElementById("airType");
    // Default to Large airports
    airTypeSel.value = "large_airport";
    const portsCountrySel = document.getElementById("portCountry");
    const portTypeSel = document.getElementById("portType");
    const cityCountrySel = document.getElementById("cityCountry");
    const cityMegaChk = document.getElementById("cityMega");
    const cityLargeChk = document.getElementById("cityLarge");

    document.getElementById("airportsForm").addEventListener("submit", async (e) => { e.preventDefault(); await loadAirports(); });
    document.getElementById("portsForm").addEventListener("submit", async (e) => { e.preventDefault(); await loadPorts(); });
    document.getElementById("citiesForm").addEventListener("submit", async (e) => { e.preventDefault(); await loadCities(); });

    document.getElementById("airportsReset").addEventListener("click", async () => { airCountrySel.value = ""; airTypeSel.value = "large_airport"; await loadAirports(); });
    document.getElementById("portsReset").addEventListener("click", async () => { portsCountrySel.value = ""; portTypeSel.value = ""; await loadPorts(); });
    document.getElementById("citiesReset").addEventListener("click", async () => { cityCountrySel.value = ""; if (cityMegaChk) cityMegaChk.checked = true; if (cityLargeChk) cityLargeChk.checked = true; await loadCities(); });

    // Icon factories and legend builders
    function smallPinIcon(faName, bg) {
      return L.divIcon({
        html: `<span style="display:inline-flex;align-items:center;justify-content:center;width:16px;height:16px;border-radius:8px;background:${bg};color:#fff;border:1px solid #0003;box-shadow:0 1px 3px rgba(0,0,0,.35);"><i class="fa-solid fa-${faName}" style="font-size:9px;"></i></span>`,
        className: '',
        iconSize: [16, 16],
        iconAnchor: [8, 8],
        popupAnchor: [0, -8]
      });
    }
    function airportIcon(t) {
      const type = (t || '').toLowerCase();
      if (type.includes('heli')) return smallPinIcon('helicopter', '#a78bfa');
      if (type.includes('closed')) return smallPinIcon('plane-circle-xmark', '#94a3b8');
      if (type.includes('large')) return smallPinIcon('plane', '#1e90ff');
      if (type.includes('medium')) return smallPinIcon('plane', '#38bdf8');
      if (type.includes('small')) return smallPinIcon('plane', '#22c55e');
      return smallPinIcon('plane', '#1e90ff');
    }
    function portIcon(t) {
      const type = (t || '').toLowerCase();
      if (type.includes('lake') || type.includes('inland')) return smallPinIcon('ship', '#06b6d4');
      if (type.includes('sea')) return smallPinIcon('ship', '#3b82f6');
      return smallPinIcon('anchor', '#1d4ed8');
    }
    function portDisplayLabel(t) {
      const s = (t || '').toLowerCase();
      if (s.includes('lake') || s.includes('inland')) return 'Lake port';
      if (s.includes('sea')) return 'Sea port';
      return 'Port';
    }

    function cityStyle(cls) {
      const c = (cls || '').toLowerCase();
      if (c.includes('mega')) return { color: '#0f172a', weight: 1, fillColor: '#f59e0b', fillOpacity: 0.6, radius: 5 };
      if (c.includes('large')) return { color: '#0f172a', weight: 1, fillColor: '#60a5fa', fillOpacity: 0.55, radius: 3 };
      return { color: '#0f172a', weight: 1, fillColor: '#34d399', fillOpacity: 0.5, radius: 2 };
    }

    // Legend helpers
    function smallBadgeHTML(bg, fa) {
      return `<span class="marker-swatch"><span style="display:inline-flex;align-items:center;justify-content:center;width:16px;height:16px;border-radius:8px;background:${bg};color:#fff;border:1px solid #0003;"><i class="fa-solid fa-${fa}" style="font-size:9px;"></i></span></span>`;
    }
    function legendLineHTML() {
      return `<span class="line-swatch"></span>`;
    }
    function rebuildLegend() {
      const el = document.getElementById('legend');
      const items = [];

      // Airports
      items.push([smallBadgeHTML('#1e90ff','plane'), 'Large airport']);
      items.push([smallBadgeHTML('#38bdf8','plane'), 'Medium airport']);
      items.push([smallBadgeHTML('#22c55e','plane'), 'Small airport']);
      items.push([smallBadgeHTML('#a78bfa','helicopter'), 'Heliport']);
      items.push([smallBadgeHTML('#94a3b8','plane-circle-xmark'), 'Closed airport']);

      // Ports
      items.push([smallBadgeHTML('#3b82f6','ship'), 'Sea port']);
      items.push([smallBadgeHTML('#06b6d4','ship'), 'Lake port']);

      // Cities
      items.push([`<span class="marker-swatch" style="width:16px;height:16px;"><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#f59e0b;border:1px solid #00000033;"></span></span>`, 'Megacity']);
      items.push([`<span class="marker-swatch" style="width:16px;height:16px;"><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#60a5fa;border:1px solid #00000033;"></span></span>`, 'Large city']);

      // Routes
      items.push([legendLineHTML(), 'Route']);

      el.innerHTML = items.map(([sw, label]) => `<div class="item">${sw}<span>${label}</span></div>`).join('');
    }

    // Feature info panel helpers
    const featureInfoEl = document.getElementById('featureInfo');
    function showAttributes(title, attrs) {
      if (!featureInfoEl) return;
      const entries = Object.entries(attrs || {});
      const rows = entries.slice(0, 30).map(([k,v]) => {
        const val = (v === null || v === undefined) ? '' : String(v);
        return `<div class="item"><strong style="min-width:120px;display:inline-block;">${escapeHtml(k)}</strong> <span>${escapeHtml(val)}</span></div>`;
      }).join('');
      featureInfoEl.innerHTML = `<div class="item"><span><b>${escapeHtml(title)}</b></span></div>` + rows;
    }

    // Helpers
    function getBbox() {
      const b = map.getBounds();
      return { minLat: b.getSouth(), minLon: b.getWest(), maxLat: b.getNorth(), maxLon: b.getEast() };
    }

    async function bootstrapFilters() {
      if (!supabaseClient) return;
      showLoading(true);

      try {
        const { data: air, error: airErr } = await supabaseClient
          .from('airports')
          .select('iso_countr')
          .not('iso_countr','is', null)
          .limit(5000);
        if (airErr) throw airErr;
        const uniqAir = [...new Set(air.map(r => r.iso_countr))].filter(v => EA_ISO.includes(v)).sort();
        fillSelect(airCountrySel, uniqAir);
      } catch (e) { console.warn('Airports country list error', e); }

      try {
        const { data: p, error: pErr } = await supabaseClient
          .from('ports')
          .select('"Country"')
          .limit(5000);
        if (pErr) throw pErr;
        const uniqP = [...new Set(p.map(r => r.Country))].filter(v => EA_COUNTRIES.includes(v)).sort();
        fillSelect(portsCountrySel, uniqP);
      } catch (e) { console.warn('Ports country list error', e); }

      try {
        const { data: c, error: cErr } = await supabaseClient
          .from('cities')
          .select('"Country"')
          .limit(5000);
        if (cErr) throw cErr;
        const uniqC = [...new Set(c.map(r => r.Country))].filter(v => EA_COUNTRIES.includes(v)).sort();
        fillSelect(cityCountrySel, uniqC);
      } catch (e) { console.warn('Cities country list error', e); }

      showLoading(false);
    }

    function fillSelect(sel, list) {
      sel.innerHTML = '<option value="">All</option>' + list.map(v => `<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`).join('');
    }
    function escapeHtml(s) { return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }

    // ---- Countries from Supabase Storage (updated) ----
    async function getCountriesFileUrl() {
      if (!supabaseClient) throw new Error('No Supabase client');
      const storage = supabaseClient.storage.from(STORAGE_BUCKET);

      if (USE_SIGNED_URL_FOR_COUNTRIES) {
        const { data, error } = await storage.createSignedUrl(COUNTRIES_FILE, 60);
        if (error) throw error;
        return data.signedUrl;
      } else {
        const { data } = storage.getPublicUrl(COUNTRIES_FILE);
        return data.publicUrl;
      }
    }

    async function loadCountries() {
      if (!supabaseClient) return;
      showLoading(true);
      countriesLayer.clearLayers();
      try {
        const url = await getCountriesFileUrl();
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const gj = await res.json();

        let toAdd = null;
        if (gj && gj.type === 'FeatureCollection' && Array.isArray(gj.features)) {
          // Filter to EA if possible; fall back to all features
          const filtered = gj.features.filter(isEAFeature);
          toAdd = { type: 'FeatureCollection', features: filtered.length ? filtered : gj.features };
        } else if (gj && gj.type === 'Feature' && gj.geometry) {
          toAdd = gj;
        }

        if (toAdd) {
          countriesLayer.addData(toAdd);
          logDiag('Countries loaded from Storage');
        } else {
          logDiag('Countries file parsed but contained no features', false);
        }
      } catch (e) {
        console.warn('Countries load error', e);
        logDiag(`Countries fetch failed: ${e.message || e}`, false);
      }
      showLoading(false);
    }
    // ---------------------------------------------------

    function isEAFeature(f) {
      const props = f && f.properties ? f.properties : {};
      const keys = ['ADMIN','NAME','COUNTRY','name','sovereignt','SOVEREIGNT','NAME_EN','BRK_NAME','NAME_LONG','FORMAL_EN','WB_A2','WB_A3','ISO_A2','ISO_A3','ADM0_A3','ADMIN_NAME'];
      const first = keys.map(k => props[k]).find(v => v);
      if (!first) return false;
      const norm = String(first).trim().toLowerCase();
      if (norm.length === 2) return EA_ISO.some(c => c.toLowerCase() === norm);
      return EA_COUNTRIES.some(c => norm === c.toLowerCase() || norm.includes(c.toLowerCase()));
    }

    // Loaders
    let didInitialFit = false;
    async function loadAll(opts = { doFit: false }) {
      if (!supabaseClient) { logDiag('Not connected', false); return; }
      await Promise.all([loadCountries(), loadAirports(), loadPorts(), loadCities(), loadRoutes()]);
      if (opts.doFit || (!didInitialFit)) { fitToData(); didInitialFit = true; }
      resetIdleTimer();
    }

    async function loadAirports() {
      if (!supabaseClient) return;
      showLoading(true);
      airportsLayer.clearLayers();
      try {
        let q = supabaseClient
          .from('airports')
          .select('ident,type,name,"Name2",latitude_d,longitude_,iso_countr')
          .not('latitude_d','is', null)
          .not('longitude_','is', null)
          .limit(20000);

        const selCountry = airCountrySel.value;
        const selType = airTypeSel.value;
        if (selCountry) q = q.eq('iso_countr', selCountry);
        if (selType) q = q.ilike('type', selType);

        const { data, error } = await q;
        if (error) throw error;

        let count = 0;
        for (const r of data || []) {
          const lat = Number(r.latitude_d), lon = Number(r.longitude_);
          if (!isFinite(lat) || !isFinite(lon)) continue;
          const mk = L.marker([lat, lon], { icon: airportIcon(r.type) })
            .bindPopup(`<b>${escapeHtml(r.name || r.ident || 'Airport')}</b><br>Alt name: ${escapeHtml(r["Name2"] || '')}<br>Type: ${escapeHtml(r.type || '')}<br>Country: ${escapeHtml(r.iso_countr || '')}`);
          mk.on('click', () => showAttributes('Airport', { ident: r.ident, name: r.name, alt_name: r["Name2"], type: r.type, country: r.iso_countr, latitude: lat, longitude: lon }));
          airportsLayer.addLayer(mk);
          count++;
        }
        logDiag(`Airports loaded: ${count} features`);
        if (count === 0) logDiag('Airports query returned zero rows. Check RLS or filters.', false);
      } catch (e) { console.error('Airports error', e); logDiag(`Airports query failed: ${e.message || e}`, false); }
      showLoading(false);
    }

    async function loadPorts() {
      if (!supabaseClient) return;
      showLoading(true);
      portsLayer.clearLayers();
      try {
        let q = supabaseClient
          .from('ports')
          .select('"Port Name","Type","Country","Latitude","Longitude"')
          .limit(8000);

        const c = portsCountrySel.value;
        const t = portTypeSel.value;
        if (c) q = q.eq('Country', c);
        if (t) {
          if (t === 'Lake') {
            q = q.in('Type', ['Inland','Lake']);
          } else {
            q = q.ilike('Type', t);
          }
        }

        const { data, error } = await q;
        if (error) throw error;
        let count = 0;
        for (const r of data || []) {
          const lat = Number(r['Latitude']), lon = Number(r['Longitude']);
          if (!isFinite(lat) || !isFinite(lon)) continue;
          const mk = L.marker([lat, lon], { icon: portIcon(r['Type']) })
            .bindPopup(`<b>${escapeHtml(r['Port Name'])}</b><br>Type: ${escapeHtml(portDisplayLabel(r['Type']))}<br>Country: ${escapeHtml(r['Country'] || '')}`);
          mk.on('click', () => showAttributes('Port', { name: r['Port Name'], type: portDisplayLabel(r['Type']), country: r['Country'], latitude: lat, longitude: lon }));
          portsLayer.addLayer(mk);
          count++;
        }
        logDiag(`Ports loaded: ${count} features`);
      } catch (e) { console.error('Ports error', e); logDiag(`Ports query failed: ${e.message || e}`, false); }
      showLoading(false);
    }

    async function loadCities() {
      if (!supabaseClient) return;
      showLoading(true);
      citiesLayer.clearLayers();
      try {
        let q = supabaseClient
          .from('cities')
          .select('"City","Country",populati_1,latitude,longitude')
          .not('latitude','is', null)
          .not('longitude','is', null)
          .limit(12000);

        const c = cityCountrySel.value;
        const classes = [];
        if (cityMegaChk && cityMegaChk.checked) classes.push('Megacities');
        if (cityLargeChk && cityLargeChk.checked) classes.push('Large Cities');
        if (c) q = q.eq('Country', c);
        if (classes.length) q = q.in('populati_1', classes);

        const { data, error } = await q;
        if (error) throw error;
        let count = 0;
        for (const r of data || []) {
          const lat = Number(r.latitude), lon = Number(r.longitude);
          if (!isFinite(lat) || !isFinite(lon)) continue;
          const style = cityStyle(r.populati_1);
          const mk = L.circleMarker([lat, lon], style)
            .bindPopup(`<b>${escapeHtml(r.City || 'City')}</b><br>Class: ${escapeHtml(r.populati_1 || '')}<br>Country: ${escapeHtml(r.Country || '')}`);
          mk.on('click', () => showAttributes('City', { city: r.City, class: r.populati_1, country: r.Country, latitude: lat, longitude: lon }));
          citiesLayer.addLayer(mk);
          count++;
        }
        logDiag(`Cities loaded: ${count} features`);
      } catch (e) { console.error('Cities error', e); logDiag(`Cities query failed: ${e.message || e}`, false); }
      showLoading(false);
    }

    async function loadRoutes() {
      routesLayer.clearLayers();
      if (!supabaseClient) return;
      showLoading(true);
      try {
        let q = supabaseClient
          .from('routes')
          .select('start_lat,start_lon,end_lat,end_lon,name,mode')
          .limit(20000);

        const { data, error } = await q;
        if (error) { console.info('Routes table missing or error', error); showLoading(false); return; }

        let count = 0;
        for (const r of data || []) {
          const a = [Number(r.start_lat), Number(r.start_lon)];
          const b2 = [Number(r.end_lat), Number(r.end_lon)];
          if (a.some(v => !isFinite(v)) || b2.some(v => !isFinite(v))) continue;
          const line = L.polyline([a, b2], { color: '#eab308', weight: 2, opacity: 0.85 });
          line.bindPopup(`<b>${escapeHtml(r.name || 'Route')}</b><br>Mode: ${escapeHtml(r.mode || '')}`);
          const distKm = (map.distance(a, b2) / 1000).toFixed(1);
          line.on('click', () => showAttributes('Route', { name: r.name || 'Route', mode: r.mode || '', start_lat: a[0], start_lon: a[1], end_lat: b2[0], end_lon: b2[1], distance_km: Number(distKm) }));
          routesLayer.addLayer(line);
          count++;
        }
        logDiag(`Routes loaded: ${count} features`);
      } catch (e) { console.warn('Routes load error', e); logDiag(`Routes query failed: ${e.message || e}`, false); }
      showLoading(false);
    }

    async function runTests() {
      diag.textContent = '';
      if (!supabaseClient) { logDiag('Not connected. Auto connect should be active.', false); return; }
      try {
        // UI defaults tests
        try { logDiag('Airport type defaults to Large', document.getElementById('airType').value === 'large_airport'); } catch(e) { logDiag('Airport default type test failed', false); }
        try { const m = document.getElementById('cityMega'); const l = document.getElementById('cityLarge'); logDiag('Cities default show Mega and Large', !!m && !!l && m.checked && l.checked); } catch(e){ logDiag('City default class test failed', false); }

        // Basic table probes
        const { data: p1, error: e1 } = await supabaseClient.from('ports').select('"Port Name","Type","Country","Latitude","Longitude"').limit(1);
        if (e1) throw e1;
        logDiag('Ports select returns expected columns', Array.isArray(p1));

        const { error: e2 } = await supabaseClient.from('airports').select('ident,"Name2"').limit(1);
        logDiag('Airports select with "Name2" ok', !e2);

        const { error: e3 } = await supabaseClient.from('cities').select('"City","Country",latitude,longitude').limit(1);
        logDiag('Cities select ok', !e3);

        // Countries storage file probe
        try {
          const url = await getCountriesFileUrl();
          logDiag('Countries storage URL obtainable', typeof url === 'string' && url.length > 0);
        } catch (e) {
          logDiag(`Countries storage URL error: ${e.message || e}`, false);
        }

        // Icon size tests
        try {
          const a = airportIcon('large_airport');
          const p = portIcon('Sea');
          const okSize = JSON.stringify(a.options.iconSize) === JSON.stringify([16,16]) && JSON.stringify(p.options.iconSize) === JSON.stringify([16,16]);
          logDiag('Airport/Port icons are 16x16', okSize);
        } catch (e) { logDiag(`Icon factory threw: ${e.message || e}`, false); }

        // Legend build test
        try {
          rebuildLegend();
          const legendText = document.getElementById('legend').textContent;
          const legendHas = legendText.includes('Sea port');
          const legendHasLake = legendText.includes('Lake port');
          logDiag('Legend rebuilt and contains entries', legendHas && legendHasLake);
        } catch (e) { logDiag(`Legend build failed: ${e.message || e}`, false); }

        // Feature info panel test
        try { showAttributes('Test', {foo: 'bar', num: 1}); const t = document.getElementById('featureInfo').textContent; logDiag('Feature info panel updates', t.includes('foo') && t.includes('bar')); } catch(e) { logDiag(`Feature info test failed: ${e.message || e}`, false); }

        // Idle timer test
        try { logDiag('Idle timer is 90 seconds', getIdleMs() === 90 * 1000); } catch (e) { logDiag(`Idle timer test threw: ${e.message || e}`, false); }

        // Layer type tests (no clustering)
        logDiag('Layers are plain LayerGroups',
          airportsLayer instanceof L.LayerGroup &&
          portsLayer instanceof L.LayerGroup &&
          citiesLayer instanceof L.LayerGroup);

      } catch (err) {
        logDiag(`Unexpected test error: ${err.message || err}`, false);
      }
    }

    // Auto connect on load, then build legend and load
    if (DEFAULT_URL && DEFAULT_KEY) {
      try {
        supabaseClient = window.supabase.createClient(DEFAULT_URL, DEFAULT_KEY);
      } catch (e) {
        logDiag(`Supabase init failed: ${e.message || e}`, false);
      }
      rebuildLegend();
      bootstrapFilters().then(() => loadAll({ doFit: true })).then(() => resetIdleTimer());
    } else {
      rebuildLegend();
    }
  });
</script>

<!-- No elongated hyphens used. -->
</body>
</html>
